##### 
###### TASK 1 
1.  
整形int long short byte  
字符 char  
浮点型 double float  
布尔型 boolean  
2.  int     4个字节   -2^31 -- 2^31 - 1  
    byte 1个字节  -128--127  
    short  2个字节  -32768--32767
     long  8个字节   -2^63--2^63 -1    
3.    自动转换，52，在进行运算时计算机会将顺序小于int的转换成int类型，  
    ‘0’以char类型储存时的值为48，转换成int是就变为48，a+c就=52  
 4.   integer为包装类，包装类与包装类的比较是地址的比较，  
	 x和y在赋值前就使用了新的地址，所以不相等。而要付给z和k的值  
	 在创建好的数据范围内且没有new一个地址，所以z和k都是使用了  
	 原先创建好的数的地址且数的大小相等，所以z= =k。对于m和p， 
	 要付给它们的值超过了原先储存好的值（即为-128--127），所以  
	 都会创建一个新的空间，其地址当然不同，所以第三行为false  
	 
 

###### TASK 2 

5.  结果   13   
		 6+8  
	  ++a为前置++，先运行a=a+1在回到原代码中  
	  b++为后置++，先将b放在原代码中运行完本次后在运行b=b+1  
6.     
		a         0000------0010  
	 -a的补码   1111------1110
		 a&-a  0000------0010
		 a&-a=  a的补码只保留最低位的1及其后面的0的二进制对应的数
		 


	

